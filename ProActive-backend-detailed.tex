\subsection{ProActive backend for ABS}
The ProActive backend for ABS is another translator that generates the ProActive code 
corresponding to an ABS program. This backend allows ABS program to run in distributed 
environments thanks to the support of ProActive. For that, all ABS concepts are simulated 
with ProActive, since the two languages are based on different active object models. The 
main challenges in the translation are (i) how to efficiently support object groups in 
ProActive where there only exist active and passive objects, (ii) how to address objects 
in the translation since objects are passed by reference in ABS and by copy in ProActive, 
and (iii) how to simulate cooperative scheduling with multi-threading controlled through 
annotations. We first present object referencing aspects as scheduling is in fact 
dependent on the set of objects that are decided to be active ones.

\paragraph{Data sharing and object referencing}
In the translation from ABS to ProActive, we need to define what happens in ProActive when a new ABS object is created. In particular, we need to define the ProActive code that would be equivalent to the ABS new cog statement.
As in ABS objects should be accessible from all others, one could think that implementing all objects with a ProActive active object would meet the requirement. However, in practice, this is hardly manageable: a ProActive active object is associated a plain Java thread. Thus, this solution would inevitably lead to a substantial memory consumption and context switch overhead.
In the code generated by the ProActive backend, only the COGs are active objects, and thus are the entry points to all the objects they contains. Thanks to this hierarchy, objects other than COG objects remain passive, which preserves the performance of the ProActive backend.
Thus, we have a two-level hierarchical indexing of objects:
\begin{itemize}
\item A first level of network-wide accessible COG objects. This mechanism is integrated in ProActive as it is based on RMI~\cite{Wollrath:1996:DOM:1268049.1268066}.
\item A second level of locally-accessible objects. This mechanism is implemented in the COG class using a map from object identifiers to object references.
\end{itemize}
This classification implies that the application always manipulates local references except for COG objects that can be manipulated through remote references.
Consider the following ABS \code{new cog} statement:
\lstset{ numberstyle=\tiny, stepnumber=1, numbersep=2pt, basicstyle=\ttfamily\scriptsize, keywordstyle=\bfseries,
    showstringspaces=false}
\begin{lstlisting}
Server server = new cog Server();
\end{lstlisting}
We translate this single line of code into the following ProActive code:
\begin{lstlisting}
Server server = new Server();			
COG cog = PAActiveObject.newActive(COG.class, new Object[]{Server.class}, node);			
server.setCog(cog);				
cog.registerObject(server);	
\end{lstlisting}
Line \code{1} creates a regular server object. Lines
\code{2-3} use the \code{newActive} ProActive primitive to create
a new COG active object. Additionally to the constructor parameters, ProActive allows to
 specify onto which node the active object should be deployed at runtime.
Line \code{4} makes the local server aware of its COG.
Finally in line \code{5}, due to the ProActive by-copy parameter passing, the server object is copied in the local memory space of the newly created COG, and is thus locally accessible there.  
For other objects created with \code{new} in ABS, the ProActive backend simply registers them locally in the current COG. Consequently, they can be only referenced locally until they are passed.
With this hierarchical referencing,
it is not technically possible to directly run an asynchronous method call on a object that belongs to a different COG, as it is done in ABS, so we need an adapted translation of asynchronous method calls in ProActive.
Consider this ABS snippet:
\begin{lstlisting}
server!start();
\end{lstlisting}
in the ProActive backend, the principle to translate this is to run an asynchronous method call on the COG of \code{server} and then let this method retrieve the server object and run the desired method on it.
More precisely, here is the translation the ProActive backend provides:
\begin{lstlisting}
server.getCog().execute("start", new ABSType(){}, server.getId());
\end{lstlisting}
More precisely, we first retrieve a reference to the COG of the server object by using the local reference of the server object. Note that this copy of server object is not the one we want to reach since it does not lie in the right COG. 
Then, a generic \code{execute} method of the COG class is called on the COG object returned by \code{getCog()}, and this method call is implicitly asynchronous by the nature of the COG object. When the \code{execute} request is run, it uses the identifier of the targeted object to lookup the reference of the server object that is local to the targeted COG, and then run the \code{start} method synchronously on it by reflection. 
In summary, in the ProActive translation of ABS programs, object references are hidden behind COG references, that are globally known in order to give an entry point to local objects. This way, the performance of the generated distributed applications with the ProActive backend can be preserved.


In ProActive, passive objects are not shared between active objects. Therefore, when a passive object is a parameter of a remote method call, it is copied, whereas in ABS parameters of method call are manipulated by reference.
In particular, when in the translation we run an \code{execute} method call, all the parameters are copied. For the identifier of the targeted object and the name of the method to run, this is not a problem because they are immutable variables, so having many independent copies of them does not change the behavior of the program. Apart from those parameters, the \code{execute} method also copy the parameters of the method to run by reflection.
for example, consider an ABS asynchronous method call like this one:
\begin{lstlisting}
server!start(p1, p2);
\end{lstlisting}
This asynchronous method call has two parameters, \code{p1} and \code{p2}. 
This is translated through the ProActive backend this way:
\begin{lstlisting}
server.getCog().execute("start", new ABSType(){p1, p2}, server.getId());
\end{lstlisting}
When running the \code{execute} method, objects \code{p1} and \code{p2} are copied to be available locally in the targeted COG. Thus, two versions of \code{p1} and \code{p2} exist at this point of execution, so it is not obvious that the copies of \code{p1} and \code{p2} reflect the latest modifications when the \code{start} method is executed, as it is the case in ABS. But in practice, if the \code{start} method uses \code{p1} and \code{p2}, it means that a method is called on them. And we have seen that a method call is translated by dropping a request in the COG that manages the original object. In consequence, any method call on the copies of \code{p1} or \code{p2} will end up in manipulating the original versions of \code{p1} and \code{p2}. Thanks to this mechanism, the initial data sharing of ABS is correctly simulated even with the no-sharing philosophy of ProActive.
In the end, in the ProActive translation of ABS, when we copy an object from one node to another, we only need the identifier of the object, to be able to retrieve it in the right memory space, and a reference to its COG, that is globally accessible. All the others attributes of the objects can actually be omitted since they will not be used when copied. This observation allows us to optimize object copy to reduce at minimum the amount of information that is sent through the network. In summary, the ProActive backend generate ProActive programs that copy few data but that, in return, incur more communications.

\paragraph{Thread creation and scheduling}
Multiactive objects provide several mechanisms to control the scheduling of requests. The right tuning of those controls allows the ProActive to simulate the behavior of ABS cooperative scheduling.

\smallskip
$\bullet$ \textit{Translation of ABS \code{await} statement on futures.}
Consider this ABS snippet:
\lstset{ numberstyle=\tiny, stepnumber=1, numbersep=2pt, basicstyle=\ttfamily\scriptsize, keywordstyle=\bfseries,
    showstringspaces=false}
\begin{lstlisting}
Fut<Bool> ready = server!start(); (1)
await ready?;                     (2)
\end{lstlisting}
We translate the \code{await} statement with a ProActive primitive, \code{getFutureValue}, that forces a wait-by-necessity on the passed future, as follows:
\begin{lstlisting}
PAFuture.getFutureValue(ready);   (2)
\end{lstlisting}
The issue here is that the \code{getFutureValue} primitive is blocking. With no further configuration, no other request would be executed in this COG until the future is resolved, which is not the expected behavior. 
In ProActive multiactive objects, a way to control what happens when a thread switches in wait-by-necessity is to specify the kind of thread limit (in addition to the thread number) that is used by the considered multiactive object: a hard limit restricts the total number of threads whereas a soft limit only restricts the number of threads that are active (not in wait-by-necessity).
Thus, in order to achieve the desired request scheduling, we configure the COG class and its \code{execute} method with multiactive object annotations as follows:
\begin{figure}[!h]
	\setlength\abovecaptionskip{0.25mm}
	\lstset{ numberstyle=\tiny, stepnumber=1, numbersep=2pt, basicstyle=\ttfamily\scriptsize, keywordstyle=\bfseries,
    showstringspaces=false,
    deletekeywords={true, false, public, class},
    morekeywords={@DefineThreadConfig,@Group,@MemberOf}}
\begin{lstlisting}
@DefineGroups({
  @Group(name="scheduling", selfCompatible=true)
})
@DefineThreadConfig(threadPoolSize=1, hardLimit=false)
public class COG {
  ...
  @MemberOf("scheduling")
  public ABSValue execute(UUID objectID, String methodName, ABSType[] args) {
  ...
  }
  ...
}
\end{lstlisting}
\end{figure}
A particular group of requests named \code{scheduling} is declared as \code{selfCompatible}, so that several requests of this group are allowed to execute in parallel.
The \code{execute} method is put in the \code{scheduling} group.
Finally, an instance of COG has a thread limit of 1 (\code{threadPoolSize = 1}), and this limit is not a hard limit (\code{hardLimit = false}). So there can exist only one active thread at a time in a COG multiactive object, and, since they are compatible, an \code{execute} request is allowed to be executed when another \code{execute} request is in wait-by-necessity. Consequently, this annotation configuration leads to a similar scheduling as ABS
	
\smallskip
$\bullet$ \textit{Translation of ABS \code{get} statement.}
The translation of the ABS \code{get} statement would have been straightforward if we had not configured the COG class for the translation of the \code{await} statement. Indeed, by doing so, we have disabled the blocking aspect of the ProActive \code{getFutureValue} primitive. 
Consequently, what is required to translate the \code{get} statement is to temporarily go back to the initial behavior of the ProActive \code{getFutureValue} primitive (like without annotations).
To do that, we temporarily set a hard limit, just for the time the future is waited, so that no other thread can start or resume a request. An ABS \code{get} statement like in \code{ready.get} is translated in ProActive like this:
\begin{lstlisting}
getCOG().switchHardLimit(true);
PAFuture.getFutureValue(ready);  
getCOG().switchHardLimit(false);
\end{lstlisting}
The call to the COG is synchronous since the retrieved COG is the local one, and therefore, we are sure that the limit is switched when executing the next line of code. This way the semantics of \code{get} is preserved in the ProActive translation.

\smallskip
$\bullet$ \textit{Translation of ABS \code{await} statement on conditions.}
Another usage of the ABS \code{await} statement is to use it followed by a condition. For translating this kind of \code{await}, we wrap the condition evaluation in a method call that return a future and we synchronize on it with a \code{getFutureValue} call. More precisely, for each such condition, we generate a corresponding method. Then, we translate the \code{await} statement by an asynchronous call to a generic \code{awaitCondition} method of the COG class
giving it as parameter the current object, the generated method name corresponding to the condition, and the condition members as parameters if they are not accessible from the generated method.
As an example, here is a possible ABS guard:
\begin{lstlisting}
await a == 3;
\end{lstlisting}
First, the ProActive backend generates a corresponding method \code{cond7517d1ff7c52} whose purpose is to check whether the method parameter is equal to 3 (since the second member is constant).
Then, the ABS \code{await} statement is translated into:
\begin{lstlisting}
PAFuture.getFutureValue(
    this.getCog().awaitCondition(this.getId(), "cond7517d1ff7c52", a));
\end{lstlisting}
The \code{awaitCondition} call executes by reflection the method \code{cond7517d1ff7c52} on the object retrieved with the given identifier, passing the parameter \code{a}.
In the annotations on the COG class, we create a new self compatible group of requests to gather \code{awaitCondition} requests and we increase the global thread limit in order to allow several conditions to run in parallel. To be sure that the execution thread is not taken by condition execution, we reserve one thread only for the \code{scheduling} group through an optional parameter of the \code{@Group} annotation.  
So in fact we have a clear separation between the single thread used by the \code{scheduling} group, and the threads used by the \code{waiting} group.
The COG class is thus augmented with new annotations, as follows:
	\setlength\abovecaptionskip{0.25mm}
	\lstset{ numberstyle=\tiny, stepnumber=1, numbersep=2pt, basicstyle=\ttfamily\scriptsize, keywordstyle=\bfseries,
    showstringspaces=false,
    deletekeywords={true, false, public, class},
    morekeywords={@Compatible,@Group,@MemberOf,minThreads,maxThreads,threadPoolSize}}
\begin{lstlisting}
@DefineGroups({
  @Group(name="scheduling", selfCompatible=true, minThreads=1),
  @Group(name="waiting", selfCompatible=true)
})
@DefineRules({
    @Compatible({"scheduling", "waiting"}),
})
@DefineThreadConfig(threadPoolSize=10, hardLimit=false)
public class COG {
  ...
  @MemberOf("scheduling")
  public ABSValue execute(UUID objectID, String methodName, ABSType[] args) {
  ...
  }
  @MemberOf("waiting")
  public ABSType awaitCondition(
      UUID objectID, String methodName, ABSType[] args, Class<?>[] args) {
    ...
  }
  ...
}
\end{lstlisting}

In conclusion, all ABS constructs are sustained by the ProActive backend. We have proven the translation to be correct. For that, we have used ASP, the calculus of ProActive, with multiactive objects extensions, and we have showed that the ASP translation simulates all the rules of ABS semantics, and that all translated ASP configurations correspond to a valid ABS execution. in addition, we have performed two experimental evaluations that show that (i) the ProActive backend speeds up the execution of ABS programs in a distributed environment, and (ii) that the overhead introduced by the translation is always kept under 10\%.
