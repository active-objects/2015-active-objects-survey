% v2-acmsmall-sample.tex, dated March 6 2012
% This is a sample file for ACM small trim journals
%
% Compilation using 'acmsmall.cls' - version 1.3 (March 2012), Aptara Inc.
% (c) 2010 Association for Computing Machinery (ACM)
%
% Questions/Suggestions/Feedback should be addressed to => "acmtexsupport@aptaracorp.com".
% Users can also go through the FAQs available on the journal's submission webpage.
%
% Steps to compile: latex, bibtex, latex latex
%
% For tracking purposes => this is v1.3 - March 2012

\documentclass[prodmode,acmtecs]{acmsmall} % Aptara syntax

% Package to generate and customize Algorithm as per ACM style
\usepackage[ruled]{algorithm2e}
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\small}
\SetAlCapFnt{\small}
\SetAlCapNameFnt{\small}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}
\usepackage{listings}
\newcommand{\code}[1]{\texttt{\small{#1}}}
\newcommand{\TODO}[1]{\textcolor{red}{\textbf{[TODO:#1]}}}
\newcommand{\NOTE}[1]{\textcolor{blue}{\textbf{[Note:#1]}}}
% Metadata Information
%\acmVolume{9}
%\acmNumber{4}
%\acmArticle{39}
%\acmYear{2010}
%\acmMonth{3}

% Copyright
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

% DOI
%\doi{0000001.0000001}

%ISSN
%\issn{1234-56789}

% Document starts
\begin{document}

% Page heads
%\markboth{G. Zhou et al.}{A Multifrequency MAC Specially Designed for WSN Applications}

% Title portion
\title{A Survey of Active Objects and Actors}
\author{To fill
\affil{To fill}
To fill
\affil{To fill}
To fill
\affil{To fill}
To fill
\affil{To fill}
To fill
\affil{To fill}
To fill
\affil{To fill}
To fill
\affil{To fill}}
% NOTE! Affiliations placed here should be for the institution where the
%       BULK of the research was done. If the author has gone to a new
%       institution, before publication, the (above) affiliation should NOT be changed.
%       The authors 'current' address may be given in the "Author's addresses:" block 
%(below).
%       So for example, Mr. Abdelzaher, the bulk of the research was done at UIUC, and he 
%is
%       currently affiliated with NASA.

\begin{abstract}
the abstract
\end{abstract}

\tableofcontents
%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
%\begin{CCSXML}
%<ccs2012>
% <concept>
%  <concept_id>10010520.10010553.10010562</concept_id>
%  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%  <concept_significance>500</concept_significance>
% </concept>
% <concept>
%  <concept_id>10010520.10010575.10010755</concept_id>
%  <concept_desc>Computer systems organization~Redundancy</concept_desc>
%  <concept_significance>300</concept_significance>
% </concept>
% <concept>
%  <concept_id>10010520.10010553.10010554</concept_id>
%  <concept_desc>Computer systems organization~Robotics</concept_desc>
%  <concept_significance>100</concept_significance>
% </concept>
% <concept>
%  <concept_id>10003033.10003083.10003095</concept_id>
%  <concept_desc>Networks~Network reliability</concept_desc>
%  <concept_significance>100</concept_significance>
% </concept>
%</ccs2012>  
%\end{CCSXML}

%\ccsdesc[500]{Computer systems organization~Embedded systems}
%\ccsdesc[300]{Computer systems organization~Redundancy}
%\ccsdesc{Computer systems organization~Robotics}
%\ccsdesc[100]{Networks~Network reliability}

%
% End generated code
%

% We no longer use \terms command
%\terms{Design, Algorithms, Performance}

\keywords{Active objects, actors, concurrency, distributed systems}

%\acmformat{Gang Zhou, Yafeng Wu, Ting Yan, Tian He, Chengdu Huang, John A. Stankovic,
%and Tarek F. Abdelzaher, 2010. A multifrequency MAC specially
%designed for  wireless sensor network applications.}
% At a minimum you need to supply the author names, year and a title.
% IMPORTANT:
% Full first names whenever they are known, surname last, followed by a period.
% In the case of two authors, 'and' is placed between them.
% In the case of three or more authors, the serial comma is used, that is, all author 
%names
% except the last one but including the penultimate author's name are followed by a comma,
% and then 'and' is placed before the final author's name.
% If only first and middle initials are known, then each initial
% is followed by a period and they are separated by a space.
% The remaining information (journal title, volume, article number, date, etc.) is 
%'auto-generated'.

%\begin{bottomstuff}
%This work is supported by the National Science Foundation, under
%grant CNS-0435060, grant CCR-0325197 and grant EN-CS-0329609.
%
%Author's addresses: G. Zhou, Computer Science Department,
%College of William and Mary; Y. Wu  {and} J. A. Stankovic,
%Computer Science Department, University of Virginia; T. Yan,
%Eaton Innovation Center; T. He, Computer Science Department,
%University of Minnesota; C. Huang, Google; T. F. Abdelzaher,
%(Current address) NASA Ames Research Center, Moffett Field, California 94035.
%\end{bottomstuff}

\maketitle


\TODO{TODO LIST}


list dimensions -- all: complete the list or remove or merge

describe ABS -- Reiner and Cristal, Vlad and Frank (by 27/11)

describe proactive -- Justine and Ludo (by 27/11)

use PA and ABS as a template to describe Encore -- Kiko? 

use PA and ABS as a template to describe Rebecca -- Marjan? 


\NOTE{Page limit is 35 pages}

\section{Introduction}

A global introduction to the common problems in programming distributed systems. Safety 
issues, common bugs and efficiency issues. A first overview of the families of 
programming models for concurrent and distributed systems. What is difficult? What 
features are important in concurrent? in distributed systems?

Definitions of the important notions like what is an actor or what is a future from a 
(old) historical point of view

\section{Active object Languages}

\subsection{An historical view of Actor and active-object languages}
Actors, Creol \cite{JOY06:creol}, JCobox, 

	Requirements in the design of those languages


Plus a small (or bigger) note on : JAC, 
AmbientTalk, E programming language, Erlang, 
Kilim, Scala actors, Akka, Go
\TODO{Not sure all of them should be cited but we will decide later}

Where do we put modern languages like Akka?



\subsection{Dimensions of Comparison between Languages}
\begin{itemize}
	\item Target (what for?)  / Objective of the language
	\item Degree of synchronisation (from Rebecca to ProActive) from only asynchronus 
	interactions to strong synchronisation primitives (cooperative scheduling is probably 
	an intermediate feature here)
	\item Degree of transparency: how much is the user exposed to â€¦.
	\item How much data sharing? Under which condition? extremes are probably ABS and 
ProActive/Rebecca
	\item Formal support and  formal semantics
	\item \TODO{[Added by Justine and Ludo]} Implementation and programming and execution 
	support.
\end{itemize}

\subsection{A Focus on Some Active-object Languages}
\subsubsection{Rebecca}
\subsubsection{ABS}

\lstset{ morekeywords={module,export,import, from, interface, class,
    implements, await, get, new, local,release} }

ABS (\emph{A}bstract \emph{B}ehavioral \emph{S}pecification)
\cite{JHSSS10} is an object-oriented, concurrent modeling language: in
contrast to design-oriented or architectural langauges, ABS code is
fully executable. There is a simulator as well as several code
generation backends (at the moment, for Java, Haskell, and Erlang). At
the same time, ABS abstracts away from features that make automatic
analysis difficult in mainstream programming languages. For example,
ABS has an object model, but it does not support code inheritance and
it enforces programming to interfaces as well as strong
encapsulation. It retains, however, modeling features that are
essential in realistic applications, for example, aliasing and
unbounded object creation.

The main design goal of ABS was to create a language that permits to
specify complex behavior of concurrent objects in a concise, natural
manner, while keeping automated analysis of that behavior feasible and
scalable. The central issue to achieve this goal is the concurrency
model.

The ABS concurrency model is characterized by cooperative
scheduling. This means that no task in preempted (interrupted) unless
its modeler explicitly allows to do that. There are two statements in
ABS that explicitly release control: \lstinline{release} and
\lstinline{await}. The former is unconditional while the latter has a
Boolean argument and can be used to synchronize with another task.

\begin{figure}
  \centering
\begin{lstlisting}[numbers=left,xleftmargin=4ex,escapechar=\%]
module Services;
import Data, init, modify from CustomerData;

interface Server {
  Unit process(Fut<Data> fd);
}

class Service implements Server {
  Unit process(Fut<Data> fd) {
    await fd?; %\label{abs:process:awaitd}%
    Data rd = fd.get;
    Fut<Unit> r = rd!modify();
    await r?;
}

{ // main block of %module%
Server s = new local Service(); %\label{abs:main:begin}%
Data d = new local Data(); 
Fut<Data> fd = d!init(); %\label{abs:main:init}%
Unit u = s!process(fd); %\label{abs:main:end}%
}
\end{lstlisting}  
  \caption{A simple ABS model}
  \label{fig:abs-simple}
\end{figure}

We explain the concurrency model of ABS with help of the code in
Fig.~\ref{fig:abs-simple}. The unit of distribution in ABS is a
\emph{concurrent object group} (COG) which can be thought of as a set
of tasks that share a common heap and a processor. Each task executes
code owned by an object and at most one task is active in a given COG
at any time. New tasks are created by asynchronous method calls as
well as, initially, by selecting the main block of a module. An
example of the latter is the code in
lines~\ref{abs:main:begin}--\ref{abs:main:end}.

Line~\ref{abs:main:begin} declares and creates a new object with
interface type \lstinline{Server} using the implementation in class
\lstinline{Service}.  The directive \lstinline{local} places the
object in the current COG. Without \lstinline{local} a new COG is
created together with the object. The next line declares and creates a
data object (note that type \lstinline{Data} was explicitly imported)
in the same COG. Hence, \lstinline{s} and \lstinline{d} share the same
heap. Line~\ref{abs:main:init} calls an initialization method (not
shown) on the data. The notation ``\lstinline{!}'' signifies an
asynchronous call. Its effect is to create a new task in the COG of
\lstinline{d} that executes the code of
\lstinline{init()}. Asynchronous calls do not interrupt the caller, so
the statement following the call is immediately executed. Therefore,
we need a handle by which to retrieve the result of an asynchronous
call once its result has been computed. In ABS the type of such
handles have a future annotation. Note that \lstinline{fd} and
\lstinline{d} might well be aliases of each other. As can be seen in
Line~\ref{abs:main:end}, it is possible to pass futures around. This
makes it possible to use the result of an asynchronous call in
different places without copying it.  

After execution of the main block is finished, two tasks in the
current COG wait for their execution: the calls of \lstinline{init()}
and \lstinline{process()}. None of them could have been started while
the main block was executing, because there was no synchronization
statement in the latter. ABS does not determine which of
\lstinline{init()} and \lstinline{process()} is started first. In
fact, ABS can be parameterized with different scheduling
strategies. The static analyzers of ABS take all possible scheduling
sequences into account. The important point is that between explicit
synchronisation points (\lstinline{release}, \lstinline{await}) no
data races can occur and the computations are, therefore,
deterministic. 

A synchronisation point is reached at the first statement of
\lstinline{process()} in Line~\ref{abs:process:awaitd} which makes
sure that the value of the future \lstinline{fd} is available. If
\lstinline{init()} was not scheduled before, it will be now. Once the
value of \lstinline{fd} is available, it is retrieved with a
\lstinline{get} statement. Attempting to retrieve a future value that
is not yet ready, results in blockage of the whole COG until the value
becomes available. Obviously, this can easily lead to 

Data races, Scheduler, sequence, if in different COGs, shared heap, deadlocks.

\subsubsection{ProActive and ASP}
\paragraph{General presentation}\NOTE{including the main purpose of the language}
ASP~\cite{ref:asp} is an active object programming language especially designed for
programming distributed systems. ProActive is a Java library implementing the semantics
of the ASP calculus. The language is designed taking the constraints of distributed
programming into account, and relies on RMI as the communication layer even though
another communication mechanism can be used. ProActive is intended for distribution; it
is a middleware that supports application deployment on distributed infrastructures such
as clusters, grids and clouds.Several of the design-choices of the language can be
explained by these practical concerns.

A crucial design choice of ASP and ProActive is to ensure maximal transparency for the 
programmer: active objects and futures are manipulated like usual Java objects. The 
language automatically trigger asynchronous remote invocation or synchronisation when 
needed.

Since 2010 ASP features
\emph{multi-active objects}~\cite{ref:mao} meaning that in each active object, several
threads can run in parallel, but each thread is still isolated inside a single activity. 
Such Multi-active objects feature at the same time local concurrency and global 
parallelism.

\paragraph{Language description}\NOTE{semantics; do we include a formal semantics here?}
In ASP, active objects coexist with objects that are not active. However each object is 
placed under the responsibility of an active object. An active object together with its 
service thread(s) its passive objects, and its request queue is called an activity.
Only active objects are accessible between activities. The 
objects that are not active are only accessible within an activity; if those 
objects need to be exchanged between activities, they are copied. Based on this 
clear separation, the activity is the unit of distribution. 
In ASP each thread runs inside a single activity but in the case of multi-active objects 
several threads can execute in the same active objects. 

\TODO{Do we keep the MultiASP notation or simply call it ASP?}


The language is transparent: method calls are automatically turned into asynchronous 
requests if the targeted object is a remote active object. Similarly, futures are 
implicitly created upon asynchronous calls. Futures are also transparently manipulated: 
a wait-by-necessity is automatically triggered upon an access to an unresolved future. 
In ASP, futures are first-class: they can be passed between activities. In this case, 
when the future is resolved, the result is automatically updated at all locations.

ProActive offers an API to create active objects, 
and a runtime for handling ASP features. The following is an example of ProActive program:
\lstset{
	emph={parameters,node}, 
	emphstyle=\itshape
} 
\begin{lstlisting}
T t = PAActiveObject.newActive(T.class, parameters, node);
V v = t.bar(); 	// implicit asynchronous method call
o.foo(v); 	// non-blocking operation
v.foobar(); 	// potential wait-by-necessity
\end{lstlisting}
%%% THE FOLLOWING MIGHT BE TOO DETAILLED %%%
 An active object is created using \code{newActive}, instead of the \code{new} of Java.
 The \code{newActive} primitive takes the class to instantiate, the parameters of the
 constructor, and the node on which the active object will be deployed.
 The variable \code{v} is the result of an asynchronous call; it is an
 implicit future.
% The dynamic type of \code{v} is a future that is a dynamically created subtype of 
%\code{V}. 
 When the future value is needed to continue execution, such as in \code{v.foobar()}, 
 a wait-by necessity automatically occurs if the future is not resolved. In ProActive,  
 proxies are used to handle transparently active objects and futures.
% In ProActive, when an active object is created, it is registered in the
% RMI registry delivered with Java. A local reference to this active object is also created: 
% a proxy that delegates invocations to the active object.

% The deployment specification of ProActive is based on the concept of virtual nodes: 
% a virtual node is an aggregation of physical machines that are declared in configuration 
% files (XML files). Such virtual nodes can be used in the code via their identifiers in order 
% to choose a specific machine on which to deploy an active object.

 The principle of the multi-active object programming model is to execute multiple
 requests of an active object in parallel, while controlling the concurrency. 
 In practice, the 
 programmer can declare which requests (i.e. which methods of the active object) can be 
 safely executed in parallel. The internal scheduler of an active objects will allocate 
 as many threads as necessary to run those methods in parallel.
  In 
 ProActive, 
  can be used through a metalanguage, based on Java annotations.  Such requests are 
  called \emph{compatible} requests. The 
 following is an
 example of multiactive object annotations in ProActive: 
 \lstset{morekeywords={@DefineGroups,@Compatible,@DefineRules,@Group,@MemberOf} }
\begin{lstlisting}
@Group(name="group1", selfCompatible=true)
@Group(name="group2", selfCompatible=false)
@Compatible({"group1", "group2"})
public class MyClass {
  ...
  @MemberOf("group1")   
  public ... method1(...) { ... }
  
  @MemberOf("group2")   
  public ... method2(...) { ... }
}
\end{lstlisting}
In this example, two groups of requests are defined, each of them holding one method. 
The two groups are declared to be compatible (so as their method, by extension). The 
\code{selfCompatible} parameter defines whether two different requests of the same group 
are allowed to run in parallel. At runtime, a ready request is automatically executed if 
it is compatible with requests that are already executing and with older requests in the 
queue (to avoid starvation). 

Without annotations, a multi-active object is a mono-threaded active object, 
without 
any local parallelism nor race condition. Its programming is extremely simple. If some 
parallelism is desired, compatibility should be declared between requests 
that can be safely interleaved and for which execution order do not matter.
The programmer can also use dynamic informations such as request parameters or object's 
state to decide which requests are compatible.
If necessary, the programmer can even use traditional low-level Java synchronisation 
primitives to make more requests compatible but this goes a little beyond the traditional 
active-object model.

%Programming with multiactive objects follows those principles:
%\begin{itemize}
%\item Without annotations, a mult-iactive object is a mono-threaded active object, 
%without 
%	any local parallelism nor race condition.
%\item If some  Compatible 
%	requests should access disjoint memory locations to avoid race conditions. Possibly, 
%	the expert programmer can also protect the access to some of the variables using a 
%	lower-level synchronization mechanism and declare more methods as compatible. 
%Generally, 
%	compatibility is statically declared but can also be decided \emph{dynamically} 
%depending 
%	on invocation parameters or on the object's state.
%\item If even more parallelism is required, an expert programmer can also protect the
%access to some of the variables using a lower-level synchronization mechanism and
%declare more methods as compatible.
%\end{itemize}
Other high-level specifications are available in multiactive
objects~\cite{henrio:hal-00916293}, such as request priority. To avoid thread explosion,
it is also possible to set a limit on the number of threads running in parallel.  The
limit can be applied in two ways: a hard limit restrains the overall number of threads
whereas a soft limit only counts threads that are not in wait-by-necessity. 
Additionally, threads can be limited per group.

As a conclusion, ASP and ProActive are based on the multiactive object programming
model.
This model is well adapted to non-expert because it provides high-level features for distribution 
and safe concurrency.

\NOTE{Below I write one paragraph on  each aspect we want to compare the language on. We 
will see later if these paragraphs stay here or are collected in another specific section}

\paragraph{Degree of synchronisation}
In ASP the only blocking synchronisation is the wait-by-necessity on a future, but the 
only way to have another thread running is to perform an invocation on an active object. 
Requests run until completion. Consequently, there is a lot of potential deadlocks in 
case of reentrant calls especially if no compatibility annotation is specified. On the 
contrary, synchronisation only occur when the future value is indeed needed and in 
particular future references can safely be transmitted between activities without 
requiring any additional synchronisation.

\paragraph{Degree of transparency}
In ASP the programmer is not explicitly exposed to the notion of future or active object 
except at active object creation. The syntax is the same as the syntax for sequential 
programming, there is no specific construct for waiting a future value or performing an 
asynchronous call. Very often a sequential code can be reused unchanged in a distributed 
setting.

\paragraph{Data sharing between threads and active objects}
ASP follows a strict policy of absence of sharing between active objects.Objects that are 
not active objects and are passed between activities (as request parameters or request 
results) are passed by copy. Of course this also applies to objects referenced by passed 
objects and a deep-copy mechanism is used ensuring that, when objects are transmitted 
between activities, they are copied as well as all their dependency on the destination 
side. This mechanism, which is the one used by RMI, slows down request invocation because 
of the time spent to transmit data, but accelerates request treatment because there is no 
need to contact another activity to get the value of the request parameters.

There is no coherency ensured between the different copies of a passive object, thus if 
the user wants to ensure that an object has a unique coherent state he should not 
transmit it by copy, and for example transmit an active-object reference instead.

\paragraph{Formall suport and semantics}
\TODO{TODO: do we want to put the language semantics here ?}

\TODO{add ref to semantics of ASP}

\TODO{speak about formal verification and Vercors}

\TODO{speak about formalisation in Isabelle/HOL of ASP fragments}

\paragraph{Implementation: programming and execution support}


\subsubsection{Encore}

\section{Implementation of active objects}
A comparison of Active object language implementations based on a set of comparison 
criteria including at least:

efficient implementation of the threading model (eg for cooperative scheduling)
comparie with: old java backend;
Encore explicit bytecode operations; haskell; new java backend; ProActive?

	


\section{Lessons Learned and Conclusion}

%\input{survey-parts/introduction.tex}
%\input{survey-parts/example.tex}
%\input{survey-parts/conclusion.tex}

% Appendix
%\appendix
%\section*{APPENDIX}
%\setcounter{section}{1}
%In this appendix,...

%\appendixhead{ZHOU}

% Acknowledgments
%\begin{acks}
%The authors would like to thank Dr. Maura Turolla of Telecom
%Italia for providing specifications about the application scenario.
%\end{acks}

% Bibliography
\bibliographystyle{ACM-Reference-Format-Journals}
\bibliography{2015-active-objects-survey,biblio,envisage}
                             % Sample .bib file with references that match those in
                             % the 'Specifications Document (V1.5)' as well containing
                             % 'legacy' bibs and bibs with 'alternate codings'.
                             % Gerry Murray - March 2012

% History dates
%\received{February 2007}{March 2009}{June 2009}

% Electronic Appendix
%\elecappendix

%\medskip

%\section{This is an example of Appendix section head}

\end{document}
% End of v2-acmsmall-sample.tex (March 2012) - Gerry Murray, ACM



%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
