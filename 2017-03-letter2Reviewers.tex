\documentclass{article}
\usepackage{a4wide}
\title{Reply to reviewers\\
ACM CSUR-2016-0577 Manuscript: \\``A Survey of Active Object Languages'' }

\begin{document}

\maketitle
\noindent
Dear Editor, dear reviewers,

Please find enclosed the revision of our submission to ACM Computing
Surveys. We improved our article according to the comments made by the
anonymous reviewers.

We would first like to thank the reviewers for their analysis of our
paper, and the advice they gave us.

We detail below the major changes we made in this revision. After
this, we will review in the next pages the comments of the reviewers
and explain how we addressed them.  \emph{Comments that could be
  addressed trivially and exactly as suggested by the reviewers are
  omitted}.  \bigskip

In this new version, you will find the major improvements listed below:
\begin{itemize}
\item A discussion section has been added to the paper (Section 4), it features in 
Section 4.1: Feedback on the 
comparative study of the languages, and a table summarizing the features of the different 
languages. We believe that this new section addresses many of the comments made by the 
reviewers on the first version of this article.
\item Discussion on  related languages that do not belong to the historical review of 
Section 2 has 
now be moved to Section 4.2. As suggested by the reviewers, Akka and Orleans are 
discussed in detail now, in this new Section 4.2.
\item Reviewers mentioned the following points missing in the dimensions of comparison: 
\begin{itemize}
\item Uniform versus non-uniform models: this has been integrated into
  the ``degree of data sharing'' aspect.
\item Message ordering: this has been integrated into synchronization
  aspects as it is related to the synchronisation that occur during
  communications.
\item Distribution: We added this aspect in the discussion on
  implementation, as a prerequisite to the implementation choices. We
  did not want to put this criteria as a generic language dimension
  because it influences the design of some languages like ASP, but
  others such as ABS have both local and distributed implementations.
\item The implementation of a programming language can be from scratch
  with a full compiler tool chain or it can be implemented as an API:
  we agree that this is a major point of comparison, it was already
  mentioned but not highlighted enough. We discuss this point in
  detail in the last paragraph of the new Section 4.1. We discuss this
  aspect there, because we believe that it is a point where it is
  really interesting to compare the different approaches, even if it
  could also be added as a dimension.
\end{itemize}

\item Comparison between Java~8 and the previous Java backend for ABS
  has been removed, we focus now on the comparison between ProActive
  and Java~8 backends.
\end{itemize}
\begin{itemize}
\item Introduction to Section 2.1 that presents the historical view on
  active object languages has been refocused and greatly shortened.
\item The introduction has also been significantly improved.
\end{itemize}

\noindent
Best regards,
\newline
\noindent
Frank de Boer, Vlad Serbanescu,
	Reiner H\"ahnle,
	Ludovic Henrio, Justine Rochas,
	Crystal Chang Din, Einar Broch Johnsen,
	Marjan Sirjani,
	Ehsan Khamespanah,
	Kiko Fernandez-Reyes, and Albert Mingkun Yang.

\newpage
As explained above, we quote below and reply to text requiring changes that we did not 
address in a straightforward manner:

\section*{Annex 1: response to first reviewers' comments}

\begin{quote}
This is a well-structured, readable paper on an interesting topic. Languages and language 
concepts for concurrent and distributed systems are an important research area. In 
general, the paper does a good and structured job to introduce the different languages. 
Less structured is the implementation section (Section 3) that — on the other hand — 
sketches interesting technical aspects.
\end{quote}
Implementation section is indeed a bit more complex to organize,
however, we tried to improve its readability and we believe that the
fact that the old versus new Java experiment was removed makes this
section easier to read.


\begin{quote}
The paper compares relatively similar languages. This is good for readers that want to 
engineer another language in that class or get a high-level overview. The presentation is 
less suitable for readers that are interested in comparing these (research) languages to 
programming languages or libraries that are already in wider practical use, like e.g. 
Erlang or the Akka library. A more practical oriented reader would also benefit from 
information about experiences that were made with the languages.
\end{quote}
The new Section 4.2 is specifically focused on such a comparison. We think that the 
background on research languages gives us an interesting and formally defined point of 
view to analyze those languages.

\begin{quote}
Treating the languages one after the other, and for each language the aspects of 
comparison, has the advantage that the reader gets a fairly clear introduction into the 
languages. However, this way, the comparison between the languages remains a bit shallow 
in the sense of „this language does it this way, the other language does it this way“. A 
„deeper“ language comparison of the style „what can I do with this language, that I can’t 
do with another one“ or „how complex is it to express a certain program pattern in 
language X that can easily be expressed in language Y“ is missing. 
\end{quote}
The new Section 4.1 better compares the languages, it also contains a table giving a 
summary comparison of the languages.

\begin{quote}
	In general, the citations are precise and relevant. For a survey paper, however, a 
	more 
substantial related work section would be advisable that provides a more comprehensive 
overview of languages with similar features. This applies both to programming languages 
as well as to papers on formal analysis (e.g. the book „A discipline of multiprogramming“ 
by Jayadev Misra is closely related to the topic, but not mentioned as a point of 
comparison in the missing related work section. 
\end{quote}
We added a reference to this book and to the Scoop language as the only two references 
outside the actor/active object world (except from the historical part). We know that the 
choice of which languages to mention or not is a difficult one, and is a bit arbitrary.

\begin{quote}
 Page 3, beginning of 2.1: This is a too broad presentation starting by high-level 
languages in general and ALGOL etc. Focus the history on the relevant concepts.
\end{quote}
We reduced the first two paragraphs to a few introductory sentences.


\begin{quote}
Page 12: It took me some time to understand the concurrency model of ABS. It is 
explained fairly low-level. Shouldn’t one first say that COGs process concurrently and 
communicate via messages (like actors) and then talk about the concurrency within COGs 
based on preemptively scheduled tasks. Starting the explanation with references to 
interleaving semantics (page 12 top) was misleading to me. 
\end{quote}
Indeed, we rewrote the part explaining this approach. See the beginning of the language 
description.

\begin{quote} Page 18: I had problems to understand the language description of Encore. 
It says: 
„Active objects encapsulate passive objects, and …“ and later: „In Encore, passive 
objects may be shared between active objects …“ The wording sounds contradictory to me. I 
don’t understand what encapsulation of an objects means if it is shared. Maybe the 
explanation can be improved.
\end{quote}
We explain this point in detail now.
See the new first paragraph of encore language description.


\begin{quote}
 A related work section going beyond the compared languages would be advisable.
\end{quote}
This is now the purpose of the new section 4.2.

\section*{Annex 2: response to second reviewers' comments}


\begin{quote}
	Section 2.1, page 5:
You write: "We have also made sure that the four languages discussed in detail have left 
the experimental stage and are available in stable, public distributions"

I was unable to find a stable, public distribution of the Encore language online. 
Moreover, the present paper does not provide a URL pointing to such a distribution.
\end{quote}
The URL of the public repository of Encore has now been added to the paper.

\begin{quote}
	Section 2.3.3, page 15:
In the first ProActive program that is shown I was wondering how generic types are 
handled. For instance, assuming class "O" has a generic type parameter, how would the 
creation of a new active object look like in that case?
\end{quote}
In fact, ProActive does not support the creation of futures or active objects for generic 
types (they should be embedded in another object for example). We clarified this point by 
adding the following text: ``The transparent creation of proxies has some
practical restrictions: the active objects and futures cannot be of a
primitive or generic type. If a future cannot be created, the call to
an active object is performed synchronously.''

\begin{quote}
	Section 2.3.3, page 16:
X On line 36 you write that "future references can safely be transmitted between 
activities". However, it is not clear whether this also holds for remote activities. 
Futures as they are implemented in Java, for example, are not serializable.
\end{quote}
ProActive has its own implementation of futures (implemented before the adoption of 
futures by Java) with our own serialization procedure, this allows us to implement 
transparently first-class futures. We added the following text for clarification:
``The ProActive middleware transparently handles future value
transmission~[HKRZ:Coregrid:2010] (a ProActive future has its own serialization 
procedure).''

\begin{quote}
	Section 2.3.4, page 19:
On line 51 you write that the "trait provides the interface-like feeling of OOP languages 
[..]" The usage of OOP here is not entirely appropriate: the comparison breaks down 
immediately when talking about prototype-based OOP languages like JavaScript. Therefore, 
the formulation should be adjusted to be more careful, and perhaps talk about "the 
interface-like feeling of statically-typed, Java-like OOP languages".
\end{quote}
We clarified this explanation by explicitly referring to statically typed OO languages.

\begin{quote}
	 A discussion of Orleans, an important and 
influential active object language is missing, including a citation of the following main 
references:

@InProceedings\{BykovGKLPT11,
\ldots
\}

@Article\{BernsteinB16,
\ldots
\}


If not, what important details/ideas/analyses are missing?: One of the most important and 
influential active object languages, Orleans from Microsoft, which was originally started 
as a research project in Microsoft Research, is not discussed. This is definitely an 
important discussion that is currently missing.

Orleans is also significantly more mature compared to other discussed languages like 
Encore. Orleans has been used to build a number of production services, including the 
back-end services of popular games such as Halo and Gears of War. Also, Orleans has been 
available as open source since January 2015.

Moreover, Orleans presents a unique point in the design space of active object languages, 
by virtualizing actors, and thereby simplifying distributed resource management. None of 
the presented active object languages in the paper is similar to Orleans in this respect.

For these reasons I believe that Orleans is much better suited as a representative active 
object language compared to Encore; Encore is such a recent project that I was unable to 
find a publicly accessible distribution.

\end{quote}
We agree that Orleans is a language that should be described in this paper and that we 
should have provided a precise description of its features.
We thus added a presentation of Orleans in the new section on related languages 
(Section 4.2).

We chose to present Encore for mainly two reasons. First it 
features interesting new features for an active object language from a program language 
semantic point of view: future chaining, parallel combinators, and the 
non-uniform object model is handled in an interesting manner (by the capabilities). The 
second reason is that 
Encore features a formally defined operational semantics. 
In this paper we choose to focus on languages with a precisely defined formal semantics 
and on the  semantics of the programming language, in this context we believe 
that Encore is more appropriate. 

Additionally,  the publicly available repository of Encore is now referred in the 
text.

\section*{Annex 3: response to second reviewers' comments}


\begin{quote}
	This article gives an overview of a number of active object languages and compares 
	them 
with respect to a number of design and implementation dimensions. The article starts of 
by giving a brief history of the different active object and actor languages that served 
as the foundation of the active object model. It then focuses on four languages that are 
representative of the active object family, namely Rebeca, ABS, ASP and Encore. These 
four languages are then described in detail according to a number of relevant design 
dimensions, their formal semantics and tool support. Afterwards their implementations are 
evaluated according to a another set of dimensions. 


Point in favour:\\
- The paper provides a detailed report on the different design choices made by the four 
active object languages under discussion and classifies them along a number of relevant 
dimensions. As a survey, this article is highly relevant as reference material for future 
development of the active object paradigm.

Point against:\\
- I mostly agree with the presentation of the different design dimensions that are used 
to classify the four different active object languages. However, I feel that the 
trade-offs of the different design points along this plane are not always adequately 
discussed. The paper often reads as a factual record of the four presented active object 
languages with little discussion afterwards. More specifically, I was missing a section 
with a summary table of the different design and implementation dimensions presented in 
the article accompanied by a comparison of the different trade-offs of each of the design 
choices.
\end{quote}
This has now been added in Section 4.1. This section contains both a discussion of the 
different trade-offs and a table summarizing the aspects of the different languages

\begin{quote}
	Overall I think the introduction is lacking in giving a general direction to the 
article. Why are active object languages becoming important today? What will I learn from 
reading this article regarding the situation of active object languages in the current 
state of the art? How do the four languages under analysis fit within the larger 
community of active object languages or actor languages in general?
\end{quote}
Indeed, we greatly improved the two first paragraphs of the introduction to address those 
points, we also explained more carefully why we have chosen those languages.

 \begin{quote}
	”We start with Rebeca, which is closest to the original actor model" $\Rightarrow$ 
	What do you 
mean with original actor model? [Hewitt 73] or [Agha 86]? During the late 70s and early 
80s a number of variations on the actor model were developed, each with wide varying 
semantics.
\end{quote}
We are more specific now when referring to the classical/original actor models, 
here we referred to the classical actor model [Agha 86] which we think is closer to 
Rebeca.

\begin{quote}
	”It is interesting to notice that both of them (and, to a certain extent also ABS) 
allow the programmer to depart from the pure actor model by providing local 
multi-threading" $\Rightarrow$ I definitely think this is an interesting point that could 
be 
explored further. How does local multi-threading impact the safety guarantees provided by 
the original model? However, I feel that this is a bit out of place in the introduction.
\end{quote}
We moved this point to the discussion Section 4.1 and expanded the discussion on this 
point. See second paragraph on ``Data sharing and data access''



\begin{quote}
== 2. Active Object Languages ==\\
== 2.1 A Brief History of Actor and Active Object Languages ==\\
	Historically, I would argue that ABCL is one of the first languages that combines 
	object 
oriented programming with asynchronous message passing and thus can be seen as the first 
active object language. The term "active object" is even coined in [Yonezawa 86]. The 
main distinction with the four languages discussed in the article is that ABCL implements 
a "uniform object model" where every object is a concurrent object. This is in contrast 
with the two-layer model (active vs passive objects) of later active object languages.
\end{quote}
 We added a ref to [Yonezawa 86] when introducing active objects in this section.
Concerning uniform vs.\ non-uniform, we chose to delay the discussion about this point to 
the 
dimension definition, more specifically the data sharing dimension;  we describe the 
different 
models at that point.


\begin{quote}
	Also, actor languages were originally motivated within a artificial intelligence 
	context. 
It was only later that it was identified as a general purpose concurrency model [Agha 90] 
because of the safety and liveness guarantees it provides.
\end{quote}
We now explicitly refer to the artificial intelligence context in Section 2.1:
``This loose coupling makes Actor languages conceptually
attractive for parallel and distributed programming; in fact, 
the Actor model originated from the need ``to efficiently run the
coming generation of PLANNER-like artificial intelligence languages
including those requiring a high degree of parallelism''
[Hewitt:1973].''


\begin{quote}
	== Other high-level concurrent languages ==

The concurrency model of AmbientTalk is based on the E Programming Language [Miller 2005] 
which implements a communicating event-loop (CEL) actor model. Other than asynchronous 
futures (called promises in E) its most distinguishing feature is that objects are passed 
by eventual reference between actors rather then by copy. This helps support a POLA 
(principle of least authority) style of programming, by facilitating the creation of many 
small, object-level interfaces (each eventual reference acts as a new entry point to the 
actor), rather than a single large actor-level interface. AmbientTalk's concurrency model 
remains faithful to the communicating event-loop model of E but was designed as an 
ambient-oriented programming (AmOP) language. It adds to the CEL model a number of new 
primitives to handle disconnecting and reconnecting nodes in a network where connections 
are volatile.
\end{quote}
We improved the description of AmbientTalk based on the comment from the reviewer, in 
particular with an explicit reference to E. This is now in Section 4.2.

\begin{quote}
	== 2.2 Dimensions of Comparison between Languages ==

I agree with the different design dimension presented in this section. I think they 
provide a good basis along which active object languages can be classified. Two minor 
things I am missing is what the message ordering guarantees and the message delivery 
guarantees are for each individual language.
\end{quote}
We agree that this is also an important point of comparison.
We added this as a sub-part of ``Degree of synchronization'' and explicitly mentioned 
this aspect in the description of the languages.

\begin{quote}
	== 2.3 Representative Examples of Active Object Languages ==

I would have liked to see a summary table outlining the different design dimensions for 
each of the discussed programming languages at the end of this section. This would also 
be an ideal place to discuss the different trade-offs of these design choices.
\end{quote}
Section 4.1 now presents a summary table and discusses the different trade-offs

\begin{quote}
	Table I gives a good overview of the different variations of the Rebeca language. 
However, some of the individual extensions are not properly motivated. Are the different 
extensions orthogonal to each other or can they be combined? What are the trade-offs of 
each design and how to they fit within the larger picture?
\end{quote}

We added a paragraph in Section 2.3.1 to make clear the characteristics of each 
extension. We also addressed the relation among extensions and illustrated orthogonal 
extensions.


\begin{quote}
"Loops and periodic behavior are modeled by sending messages to oneself" \texttt{=>} The downside 
of using selfsending to implement loops is that these messages can be interleaved with 
other messages from active objects not participating in the loop.
\end{quote}
This is correct.  The new release of Rebeca supports "for" and "while" loop statements, 
we removed the part about "loops" from the sentence: periodic behavior is still 
modeled as calls to oneself, which is fine, but we do not need it to model loops, which 
avoids undesired interleaving.


\begin{quote}
	"avoiding the creation of a new actor (e.g., Fig. 1, line 8)" \texttt{=>} Is the correct line 
referenced? I am not sure why that line specifically illustrates why no new actor is 
created. I am assuming the creation of new actors is avoided because when passing a 
reference to a rebec the active object and its associated runtime are not copied. Rather 
a shallow copy of the reference is made.
\end{quote}

In that sentence, we wanted to make clear that in sending a message which has a parameter 
of actor types, a copy of reference to that actor is sent. In this case, sending-by-value 
does not mean a new copy of that actor is created and sent as the parameter.
We changed that sentence to the following sentence to make it more understandable: 
"Parameters in messages sent among actors are passed by value. This is even the case if a 
reference to an actor is passed as a parameter; the sent reference is created as a 
shallow copy of the original reference, e.g., in Fig. 1 Line 8 Dispatcher sends a request 
to the server m3 and passes the reference to the client to m3 as a parameter instead of 
passing a fresh copy of the client actor."


\begin{quote}
	== 3. Implementation of Active Objects ==

Do all languages have support for distribution? I would expect this to have a large 
impact on the implementation and definitely be a very relevant dimension along which the 
different languages can be classified.
\end{quote}
This is clearly relevant and  we added this as an introduction of the dimensions in the 
implementation section. It 
is indeed a good criterion of comparison, even if the impact of 
distribution on the implementation was already 
mentioned at the most crucial points. Additionally, we made sure that the distributed 
nature of the 
implementation is clearly stated for the implementations we provide.

%++ concerning the design of the language, the support for distribution is not a 
%dimension 
%of conception for all the languages: typically the semantics of ABS is supposed to be 
%independent of the distributed nature ; of course this is not the case of ASP and 
%somehow 
%this aspect has a consequence but it might be difficult to express it as a dimension of 
%comparison of the languages.

\begin{quote}
 "The implementation of a programming language can be from scratch with a full compiler 
tool chain or it can be implemented as an API inside an established language. A third way 
to implement an active object language is to cross-translate it to another language with 
a code generation backend" => this is another implementation dimension that is hidden in 
the text and might be made explicit in the discussion.
\end{quote}
We agree and we discuss in detail these aspects in  Section 4.1. We believe that it 
is nice to discuss this point together with the trade-offs related to language 
implementations.


\begin{quote}
	== 3.2 Java 8 Backend for ABS ==

The comparison between the Java 8 backend and the old Java backend feels out of place. 
From the text I gather that the Java 8 backend seems to be a strict upgrade to the old 
Java backend. The performance comparison between both does not seem relevant to this 
article.
The comparison between the Java 8 and ProActive backend for ABS seems much more relevant 
as it highlights another design trade-off.
\end{quote}
This comparison has now been removed and we focus on the comparison between Java 8 and 
ProActive backends.

\begin{quote}
	== 4. Lessons Learned and Conclusion ==

The conclusion states that it is essential to understand the trade-offs involved in the 
design and implementation of active object languages. However, similar to the 
introduction, I feel these are not adequately highlighted here. If I were to design a 
novel active object language, how do I best navigate the design space presented in the 
article? What are the lessons learned? I feel all the different puzzle pieces are there 
but the bigger picture is missing.
\end{quote}
We believe that this issue has now been addressed in the new Section 4.1. We wrote this 
new paragraph with these questions in mind and we expect it answers them adequately.


\begin{quote}
 The comparison between the Java 8 backend and the old Java backend 
for ABS feels out of place. From the text I gather that the Java 8 backend seems to be a 
strict upgrade to the old Java backend. The performance comparison between both does not 
seem relevant to this article.
\end{quote}
The comparison between the old Java backend and the new Java 8 backend has now been 
removed.

\begin{quote}
	If not, what important details/ideas/analyses are missing?: I mostly agree with the 
presentation of the different design dimensions that are used to classify the four 
different active object languages. However, I feel that the trade-offs of the different 
design points along this plane are not always adequately discussed. The paper often reads 
as a factual record of the four presented active object languages with little discussion 
afterwards. More specifically, I was missing a section with a summary table of the 
different design and implementation dimensions presented in the article accompanied by a 
comparison of the different trade-offs of each of the design choices.
\end{quote}
We added  Section 4.1 featuring such a summary table and a discussion on the 
trade-offs offered by the different presented languages.

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
